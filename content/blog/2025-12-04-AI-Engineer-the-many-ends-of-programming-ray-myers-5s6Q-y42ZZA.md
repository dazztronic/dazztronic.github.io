+++
title = "The Many Ends of Programming - Ray Myers"
date = 2025-12-04
draft = false

[taxonomies]
author = ["AI Engineer"]
categories = ["Software engineering--Artificial intelligence","Human-computer interaction","Programming languages","Technology--Social aspects"]
tags = ["Large language models","Domain-specific languages","Formal methods","Open Hands","Prompt engineering","Software maintenance","Empathy in engineering"]

[extra]
excerpt = "Ray Myers reframes the debate about AI and programming by focusing on empathy, listening, and the plurality of possible futures for software development. Rather than treating AI as an unstoppable force or programming as a doomed profession, he urges practitioners to actively shape the future, recognizing the diversity of scenarios and the human element at the heart of software. This perspective matters because it challenges both hype and fatalism, advocating for deliberate, inclusive, and nuanced engagement with technological change."
video_url = "https://www.youtube.com/watch?v=5s6Q-y42ZZA"
video_id = "5s6Q-y42ZZA"
cover = "https://img.youtube.com/vi/5s6Q-y42ZZA/maxresdefault.jpg"
+++

## Overview

Ray Myers reframes the debate about AI and programming by focusing on empathy, listening, and the plurality of possible futures for software development. Rather than treating AI as an unstoppable force or programming as a doomed profession, he urges practitioners to actively shape the future, recognizing the diversity of scenarios and the human element at the heart of software. This perspective matters because it challenges both hype and fatalism, advocating for deliberate, inclusive, and nuanced engagement with technological change.

## üîç Key Insights & Learnings

### Creator's Unique Angle
Myers' distinctive approach is to center the conversation not on technical inevitabilities but on empathy, dialogue, and agency‚Äîemphasizing that the future of programming is not a single predetermined path but a set of scenarios shaped by collective human choices. He introduces a taxonomy of 'endgames' for programming, highlighting that multiple, context-dependent outcomes are possible and that emotional rhetoric often clouds productive discussion.

### The Core Problem
The central problem addressed is the polarized, emotionally charged discourse around AI's impact on programming‚Äîspecifically, the oversimplification of the future as either total automation or obsolescence for developers. Myers identifies the lack of nuanced, empathetic conversation as a barrier to making wise, collective decisions about the evolution of software engineering.

### The Solution Approach
Myers proposes a stepwise approach: first, recognize and name the different scenarios people envision for the future of programming (e.g., 'extreme completion', 'developer apocalypse', 'abstraction leap', 'uncharted waters', 'review economy', 'infinite pile of garbage'). Second, engage in empathetic listening and dialogue to understand the values and incentives behind these views. Third, advocate for deliberate, context-sensitive adoption of AI tools‚Äîcombining technical innovation (like domain-specific languages and formal methods) with human judgment and collaboration.

### Key Insights
- AI tools excel at generating new code but struggle with editing and maintaining legacy code‚Äîa critical, often overlooked limitation.
- The rhetoric of inevitability ('resistance is futile', 'you'll be left behind') is counterproductive and alienating; quoting science fiction villains to justify technological change should prompt self-reflection.
- Multiple 'ends' of programming are possible and may coexist across domains; the future is not monolithic but pluralistic.
- Combining abstraction leaps (e.g., domain-specific languages) with AI-driven 'extreme completion' could yield ergonomic, sustainable workflows.
- We are not passive recipients of AI's impact‚Äîwe have agency to shape the tools, practices, and values of future software development.

### Concepts & Definitions
- 'Extreme completion': AI tools performing large, discrete programming tasks with minimal human input, mainly for grunt work.
- 'Developer apocalypse' (devocalypse): A scenario where AI eliminates the need for most programmers, seen as utopian by some and dystopian by others.
- 'Abstraction leap': The idea that programming will move to a higher level of abstraction, with code as we know it becoming a low-level detail, analogous to assembly language today.
- 'Prompts as code': Using natural language prompts as the primary human-facing artifact for programming, though criticized for unpredictability and lack of clean abstraction.
- 'Infinite pile of garbage': The risk of overproducing low-quality software due to overreliance on AI completion without adequate oversight.

### Technical Details & Implementation
- AI coding agents can generate large-scale pull requests (e.g., 48 files changed in minutes) for repetitive, low-level tasks, acting as 'tech debt dirt shovelers' under close human supervision.
- Structured prompts (as in the 'parcel paper' example) can generate entire interpreters (e.g., a 220-line Python Lisp interpreter from 61 lines of prompts), but this approach is not yet robust for large-scale, real-world applications.
- Domain-specific languages (DSLs) like CSS, SQL, and regular expressions are highlighted as proven abstraction mechanisms that could be further leveraged in combination with AI.

### Tools & Technologies
- Open Hands (open source coding agent)
- Large language models (LLMs)
- Domain-specific languages (DSLs)
- Formal methods
- GitHub (for code and papers, e.g., 'parcel paper')

### Contrarian Takes & Different Approaches
- Challenges the inevitability narrative around AI and programming‚Äîargues that the future is not predetermined and that human agency is central.
- Pushes back against the idea that all programmers will (or should) be replaced, suggesting that programming's 'destiny' is not singular.
- Questions the viability of 'prompts as code' as a sustainable abstraction, citing unpredictability and lack of structure.

## üí° Key Takeaways & Actionable Insights

### What You Should Do
- Engage in empathetic, open dialogue about the future of programming‚Äîactively listen to opposing views and seek common ground.
- Experiment with combining AI-driven code generation ('extreme completion') with domain-specific languages and formal specification systems for ergonomic, sustainable workflows.
- Be deliberate in adopting AI tools: assess not just their capabilities but their impact on code quality, maintainability, and team dynamics.
- Advocate for and design systems that value both new and existing expertise, ensuring experienced developers remain integral to evolving workflows.

### What to Avoid
- Beware the trap of treating AI as a deterministic force‚Äîpassivity leads to undesirable outcomes.
- Avoid emotionally charged, exclusionary rhetoric ('resistance is futile', 'left behind') that stifles productive conversation and alienates practitioners.
- Overinvesting in AI completion without adequate abstraction or oversight risks creating an 'infinite pile of garbage'‚Äîlow-quality, unmaintainable software.

### Best Practices
- Combine technical innovation (e.g., DSLs, formal methods) with human-centered practices (empathy, dialogue, inclusion) for robust software evolution.
- Use AI tools for well-bounded, repetitive tasks under close supervision, leveraging their strengths while mitigating their weaknesses.
- Foster a culture of continuous learning and adaptation, recognizing that expertise from 'yesterday' remains valuable in new contexts.

### Personal Stories & Experiences
- Combine technical innovation (e.g., DSLs, formal methods) with human-centered practices (empathy, dialogue, inclusion) for robust software evolution.
- Use AI tools for well-bounded, repetitive tasks under close supervision, leveraging their strengths while mitigating their weaknesses.
- Foster a culture of continuous learning and adaptation, recognizing that expertise from 'yesterday' remains valuable in new contexts.

### Metrics & Examples
- AI-generated pull request: 48 files changed in minutes for a repetitive task.
- 'Parcel paper' example: 61 lines of structured prompts generating a 220-line Python Lisp interpreter.

## Resources & Links

- [Video URL](https://www.youtube.com/watch?v=5s6Q-y42ZZA)

## Value Assessment

- **Practical Value:** conceptual framework
- **Uniqueness Factor:** fresh perspective
